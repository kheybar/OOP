"""



Multi Inheritance
وراثت چندگانه یعنی یک کلاس بصورت همزمان از چندین کلاس مختلف ارث بری کند
از اون دسته مواردی است که باید خیلی خوب یادگرفت ولی تا حدامکان استفاده نکنیم چرا که مشکلات و پیچیدگی های
زیادی را به برنامه ما اضافه می کنه. یادگیری وراثت چندگانه خیلی ساده است ولی رفع مشکلات آن سخت

به کلاس هایی که به خودی خود کار خاصی را انجام نمی دهند و پایه کلاس های دیگر هستند، می گویند کلاس میکسین


مشکلات:

Diamonds Problem:
اولین مشکل در ارث بری چندگانه، مشکل الماس است. داستان از اونجایی شروع میشه که ما کلاس دی رو داریم که داره
از کلاس سی و بی ارث بری می کنه و کلاس های بی و سی دارند از کلاس آی ارث بری می کنند
اگر مطابق کدهای زیر ما  متود کال صدا زده شود، دوبار متود کال کلاس آی صدا زده می شود و این بخاطر این است که
کلاس های بی و سی هر کدام یک بار متود کال کلاس آی را صدا می زنند. مشکل خیلی بزرگی است چرا که اگر کلاس آی، کلاسی
باشد که تغییراتی را در دیتابیس ایجاد می کند، ما دوبار تغییرات را اعمال کرده ایم! و این بد است
فکر کنید کلاس آی کلاسی است که پول انتقال می دهد، اینطوری ما دوبار پول را انتقال می دهیم!!! واو

روش حل مشکل الماس:
بسیار ساده است و ما باید از متود سوپر استفاده کنیم. بجای اینکه اسم کلاس را صدا زده، سوپر را صدا بزنیم
متود سوپر کلاس بالایی رو صدا نمی زنه، بلکه کلاس بعدی رو صدا می زنه. یعنی درواقع میره و صدا میزنه متود کال
رو در اولین کلاسی که ازش ارث بری کرده و کلاس بعدی میره و کلاس بعدیش رو صدا می زنه و اصلا مهم نیست که کلاس
قبلی بصورت مستقیم از کلاس پایه ارث بری کرده. این ترتیب که اول کی رو صدا بزن، در متود رزولوشن اردر است
با دستور هلپ کلاس مدنظر می تونیم این ترتیب رو ببینیم. متود رزولوشن اردر قابل تغییر است
نکته: بیلت این آبجکت اون کلاسی است که تمامی کلاس ها ازش ارث بری می کنند


مشکل فرستادن آرگومان به متود سوپر:
ممکن است که ما نیاز به ارث مقادیری به متود های کلاس پدر داشته باشیم و داریم با سوپر کار می کنیم. در اینجا
ما به طور عادی نمی توانیم اینکار را انجام دهیم. روش جالب اینه که اول بیایم یک مقدار اولیه بهش بدیم تا
به تایپ ارور نخوریم. بعد کافیه **کیوارگس رو هم بگییرم تا همین طوری پشت سر هم ارسال بشه به کلاس پدر بعدی تا
همه به مقادیرشون برسند. هرچی بالا تر میریم، مقادیر قبلی که در کلاس های قبل استفاده شده است، پاک می شود
مشکل بعدی دقیقا همین جا است که اگر ما در کلاسی به مقداری نیاز داریم که در کلاس بعدی نیز به آن نیاز داشته
باشیم، دیگه چیزی به کلاس بعدی نمیرسه. برای حل این مشکل مجبوریم دستی تو راه مقداردهی کنیم



"""

# Multi Inheritance
class Vehicle:
    """Mixin"""
    def __init__(self, name, speed):
        self.name = name
        self.speed = speed

    def top_speed(self):
        return f'{self.name} top speed is {self.speed}'


class Car:
    """Mixin"""
    def joy(self):
        return f'Driving {self.name} is Awesome ...'


class Motor:
    """Mixin"""
    def joy(self):
        return f'Riding {self.name} is Awesome ...'


class Sedan(Vehicle, Car):
    pass


class Retro(Vehicle, Motor):
    pass


s1 = Sedan('BMW', 300)
# print(s1.top_speed())
# print(s1.joy())



# ------------- Diamonds Problem
class A:
    a_call = 0
    def call(self):
        print('class A method call')
        A.a_call += 1

class B(A):
    b_call = 0
    def call(self):
        print('class B method call')
        B.b_call += 1
        super().call()

class C(A):
    c_call = 0
    def call(self):
        print('class C method call')
        C.c_call += 1
        super().call()

class D(C, B):
    d_call = 0
    def call(self):
        print('class D method call')
        D.d_call += 1
        super().call()


# d1 = D()
# d1.call()
# print(d1.d_call)
# print(d1.b_call)
# print(d1.c_call)
# print(A.a_call)

# print(help(D)) # MRO


# ------------- Super() manage arguments
class A:
    def call(self, a='', **kwargs):
        print(f'Class A => {a}')

class B:
    def call(self, b='', a='', **kwargs):
        """getting a and assign again"""
        print(f'Class B => {b}')
        kwargs['a'] = a
        super().call(**kwargs)

class C(B, A):
    def call(self, c='', **kwargs):
        print(f'Class C => {c}')
        super().call(**kwargs)


c1 = C()
c1.call(a='aaaa', b='bbbbb', c='cccc')
