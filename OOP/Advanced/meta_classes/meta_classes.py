"""


Meta Class:
    متا کلاس ها در پایتون برای تغییر در نحوه رفتار دیگر کلاس ها به کار میرن
    متا کلاس ها بسیار بحث پیچیده ای هستند و در پروژه های کوچک استفاده نمی شود

    در مبحث داندر نیو گفتیم که کانستراکتور کلاس هست و قبل از ساخته شدن کلاس، خودش رو به شکل یک آبجکت
    ارسال میکنه به داندر نیو. سوال اصلی اینجاست که چطوری کلاسی که خودش هنوز ایجاد نشده، تبدیل به یک
    آبجکت می شه و بعد هم ارسال میشه به داندر نیو!!! اینجا بحث به سمت متا کلاس ها می رود

متا کلاس:
متا کلاس ها، کلاس هایی هستند که به ما اجازه میده رفتار بقیه کلاس ها رو تغییر بدهیم

کلاس تایپ:
کلاس تایپ سه جور م توانیم از آن استفاده کنیم(در هلپ آن نوشته):
    ما معمولا یک آبجکت رو بهش میدیم و نوع آن را به ما بر میگرداند
    اگر ما به کلاس تایپ، سه مقدار بدهیم(نام-بیسس-دیکت) بدهیم، برای ما یک کلاس جدید می سازد
    با این تعاریف، کلاس تایپ یک متا کلاس هست که ما با استفاده از اون می تونیم کلاس جدیدی ایجاد کنیم
    متا کلاس تایپ، بالا ترین و قوی ترین متا کلاس در پایتون است
    تمامی کلاس هایی که ما ایجاد می کنیم بصورت پیشفرض، کلاس تایپ رو به عنوان متا کلاس خودشون دارند
    تمامی کلاس ها برای ساخته شدن خودشون از این متا کلاس تایپ استفاده می کنند
    به همین علت زمانی که نمونه سازی می کنیم، خود کلاس تبدیل به یک آبجکت میشه و به داندر نیو، ارسال میشه
    درواقع متا کلاس تایپ، میاد کلاس رو ایجاد میکنه تا بعد بتونه خودشو ارسال کنه به داندر نمی تواند

متا کلاس ها چه کاربردی دارد:
    استفاده اون در پروژه های بزرگ است و خیلی کم پیش میاد ازش استفاده کنیم
    یکی از کاربرد های زیادش در دیزاین پترن هاست بخصوص در دیزاین پترن سینگلتون

نحوه ایجاد متا کلاس؛
    یک کلاس میسازیم که از کلاس تایپ ارث بری کنه

کجا استفاده شده:
    یکی از مواردی که تا الان استفاده شده، در جنگو است
    در مدل های جنگو، ما یک مبحث بسیار پیچیده رو با یک خط کد ساده پیاده می کنیم



"""

class A:
    pass


a1 = A()

# class type
a1.__class__.__class__ # output => <class 'type'>

b1 = type('B', (A,), {'consractor': 'this is class made by class type'})
b1 # output => <class '__main__.B'>
b1.__class__ # output => <class 'type'>
b1.consractor # output => this is class made by class type


# Singleton
class Singleton(type):
    _instance = None
    
    def __call__(self, *args, **kwargs):
        if self._instance is None:
            self._instance = super().__call__()
        return self._instance


class DB(metaclass=Singleton):
    pass


db1 = DB()
db2 = DB()

print(id(db1))
print(id(db2))